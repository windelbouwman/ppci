
from ppci.target.thumb.instructions import Orr, Lsl, Lsr, And
from ppci.target.thumb.instructions import Str2, Ldr2, Ldr3, Adr
from ppci.target.thumb.instructions import B, Bl, Bgt, Blt, Beq, Bne, Bge, Bw
from ppci.target.thumb.instructions import Mov2, Mov3, Sub3
from ppci.target.thumb.instructions import Add3, Sub, Cmp, Sub2, Add2, Mul
from ppci.target.basetarget import LabelAddress
from ppci.irmach import AbstractInstruction

%%

%terminal ADDI32 SUBI32 MULI32 ADR
%terminal ORI32 SHLI32 SHRI32 ANDI32
%terminal CONSTI32 CONSTDATA MEMI32 REGI32
%terminal CALL GLOBALADDRESS
%terminal MOVI32
%terminal JMP CJMP

%%

stm: MOVI32(MEMI32(reg), reg) 2 'self.emit(Str2, others=[0], src=[c0, c1])'
stm: MOVI32(reg, reg)         99 'self.selector.move(c0, c1)'
stm: JMP                      2 'label, tgt = tree.value; self.emit(Bw(label), jumps=[tgt])'
stm: CJMP(reg, reg)           2 'op, yes_label, yes_tgt, no_label, no_tgt = tree.value; opnames = {"<": Blt, ">":Bgt, "==":Beq, "!=":Bne, ">=": Bge}; Bop = opnames[op]; jmp_ins = AbstractInstruction(Bw(no_label), jumps=[no_tgt]); self.emit(Cmp, src=[c0, c1]);self.emit(Bop(yes_label), jumps=[yes_tgt, jmp_ins]); self.emit(jmp_ins)'

stm: reg                      0 'pass'

reg: ADDI32(reg, reg) 2 'd = self.newTmp(); self.emit(Add3, dst=[d], src=[c0, c1]); return d'
reg: ADDI32(reg, cn)          2 'return tree.children[1].value < 8' 'd = self.newTmp(); self.emit(Add2, dst=[d], src=[c0], others=[c1]); return d'
reg: ADDI32(cn, reg)          2 'return tree.children[0].value < 8' 'd = self.newTmp(); self.emit(Add2, dst=[d], src=[c1], others=[c0]); return d'
reg: SUBI32(reg, reg) 2 'd = self.newTmp(); self.emit(Sub3, dst=[d], src=[c0, c1]); return d'

reg: ORI32(reg, reg)          2 'd = self.newTmp(); self.selector.move(d, c0); self.emit(Orr, dst=[], src=[d, c1]); return d'
reg: ANDI32(reg, reg)         2 'd = self.newTmp(); self.selector.move(d, c0); self.emit(And, dst=[], src=[d, c1]); return d'

reg: SHLI32(reg, reg)         2 'd = self.newTmp(); self.selector.move(d, c0); self.emit(Lsl, dst=[], src=[d, c1]); return d'
reg: SHRI32(reg, reg)         2 'd = self.newTmp(); self.selector.move(d, c0); self.emit(Lsr, dst=[], src=[d, c1]); return d'
reg: MULI32(reg, reg) 2 'd = self.newTmp(); self.selector.move(d, c0); self.emit(Mul, dst=[d], src=[c1, d]); return d'

cn: CONSTI32                  0 'return tree.value'

reg: GLOBALADDRESS            2 'd = self.newTmp(); ln = self.selector.frame.addConstant(LabelAddress(tree.value)); self.emit(Ldr3, dst=[d], others=[ln]); return d'

reg: CONSTI32         3 'd = self.newTmp(); ln = self.selector.frame.addConstant(tree.value); self.emit(Ldr3, dst=[d], others=[ln]); return d'


reg: ADR(CONSTDATA)           2  'd = self.newTmp(); ln = self.selector.frame.addConstant(tree.children[0].value); self.emit(Adr, dst=[d], others=[ln]); return d'

reg: MEMI32(ADDI32(reg, cn))  1 'return tree.children[0].children[1].value < 32' 'd = self.newTmp(); self.emit(Ldr2, dst=[d], src=[c0], others=[c1]); return d'
reg: MEMI32(reg)      4 'd = self.newTmp(); self.emit(Ldr2, dst=[d], src=[c0], others=[0]); return d'
reg: REGI32           1 'return tree.value'
reg: CALL             1 'return self.selector.munchCall(tree.value)'


addr: reg 0 ''
